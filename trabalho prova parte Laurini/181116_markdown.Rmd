---
title: "Trabalho-Prova Econometria 3"
author: William Y. N. Suzuki
date: 16 de novembro de 2018
output: pdf_document
---


**Este trabalho foi apresentado na disciplina de econometria 3 ministrada por Márcio P. Laurini no segundo semestre de 2018. Programa de pós-graduação em economia da FEA/RP USP.**

Vamos começar trantando os dados:

```{r}
library(readxl)
library(vars)
library(rmarkdown)
library(aTSA)
library(lmtest)
library(forecast)
```

Em seguida é importante lembrar de incluir o file "etf.xlsx" no diretório.
```{r}
etf_data <- read_excel("etf.xlsx") #import file
head(etf_data)
names(etf_data)
```
Podemos ver que `etf_data$etfcaixa` e `etf_data$IBOV` *estão como character*.

Em seguida vamos fazer preparar os dados corrigindo o problema de missings e visualizar algumas características dos dados.
```{r}
#treatment for dates
date <- as.character(etf_data$X__1) 
date <- as.Date(date,"%Y-%m-%d")
class(date)
head(date)

#treatment for etf
etf<-log(as.numeric(etf_data$etfcaixa))
sum(is.na(etf)) #number of missings
plot(density(etf[!is.na(etf)]))
plot(etf,type = 'l') #plot graph of series
table(is.na(etf)*1:length(etf)) #position of missings
#treatment for missings: use flat method, where we input the last observation
#in the place of the missing
for (t in 1:length(etf)) {
  if (is.na(etf[t])==TRUE){etf[t] <- etf[t-1]} 
}
```
Na última parte acima fizemos com que sempre um *missings data* fosse substituído pela última observação.

```{r}
#treatment for ibov data
ibov <- log(as.numeric(etf_data$IBOV))
sum(is.na(ibov)) #number of missings
plot(density(ibov[!is.na(ibov)]))
plot(ibov,type = 'l')
table(is.na(ibov)*1:length(ibov)) #position of missings
#treatment for missings: use flat method where we imput the last observation
#in the place of the missing
for (t in 1:length(ibov)) {
  if (is.na(ibov[t])==TRUE){ibov[t] <- ibov[t-1]} 
}

sum(is.na(ibov)) #verify number of missings

```
Acabamos de tratar os dados da base sobre a bolsa. 

```{r}

#check the length of vectors
length(date)
length(ibov)
length(etf)

#merge the vectors
data_ibov <- cbind(date,ibov,etf)
head(data_ibov)
```
Agora vamos começar a tratar os dados sobre a produção industrial.
```{r}
#editing data of industry
industria <- read_excel("prodindustrialcapital.xls") #import data
head(industria)
names(industria)

#treatment for dates
date <- industria$Data
head(date)
class(date)
date2 <- paste(date,"01",sep='.') #we need to include the day otherwise it does not work
head(date2)
date3 <- as.Date(date2,"%Y.%m.%d")
head(date3)
class(date3)

#treatment for data about industrial production
indtr <- log(industria$Prodindustrialcapital)
head(indtr)
plot(density(indtr))
plot(indtr,type = 'l')

#check length of vectors
length(indtr)
length(date3)

#merge vectors
data_ind <- cbind(date3,indtr)
head(data_ind)
```


###Questão 2
Vamos fazer as análises.

```{r}
#build a VAR model with ibov and etf

#selecting number of lags for VAR 
VARselect(cbind(etf, ibov), lag.max =10, type="both")$selection
VARselect(cbind(etf, ibov), lag.max =10, type="trend")$selection
VARselect(cbind(etf, ibov), lag.max =10, type="const")$selection
VARselect(cbind(etf, ibov), lag.max =10, type="none")$selection
#using Schwartz criterion we use VAR(2)
```
Podemos ver que 2 lags acaba sendo escolhido pelo critério de Schwartz.

```{r}
#apply to a model VAR
model1 <- VAR(cbind(etf,ibov), p=2, type="both")
summary(model1)
dim(resid(model1))
serial.test(model1, lags.pt = 16, lags.bg = 5, type = c("PT.asymptotic") )
```

```{r}

m1 <- ca.jo(cbind(etf,ibov), type = "trace", ecdet = "trend", K = 2, spec = "transitory") 
summary(m1)
class(m1)
model2 <- vec2var(m1,r=1)
class(model2)
model2$deterministic
serial.test(model2, lags.pt = 16, lags.bg = 5, type = c("PT.asymptotic") )
```


Vamos usar 1 vetor de cointegração.
```{r}
vec <- cajorls(m1, r = 1)
vec
coef(summary(vec$rlm))
```
Respondendo a questão **2.a) Obtenha a melhor representação VAR/VEC para estes dois ativos.** O modelo VAR é de ordem 2 e portanto o VEC é de ordem 1. 
Os estimadores que encontramos para o modelo VAR são:
```{r}
model1$varresult
```


Respondendo a **2.b) Determine a dinâmica de curto e longa prazo entre essas séries.** podemos ver que a relação de cointegração é dada por
```{r}
vec$beta
```

essa é a relação de longo prazo. As relações de curto prazo são dados por:

```{r}
vec$rlm
```
para os coeficientes de <tt>etf.dl1</tt> e <tt>ibov.dl1</tt>. E podemos ver que a velocidade de ajuste são `r as.matrix(vec$rlm)[[1]][1,1]` e `r as.matrix(vec$rlm)[[1]][1,2]` mas o p-valor do segundo é de `r coef(summary(vec$rlm))[[2]][1,4]`, portanto podemos responder também **2. d) Verifique se o Ibovespa é exógena fraca nesse sistema.**, sim porque o coeficiente de ajuste para o ibovespa é estatíticamente igual a zero.


####Teste para ajuste unitário no vetor de cointegração
```{r}

res <- etf - ibov
plot(res,type="l")
adf.test(res)
```
Vemos que o resíduo do vetor de cointegração quando estabelecemos valores iguais a (1,-1) são estacionários se ajustamos para tendência ou constante. No começo da séries há um quebra drática porque a *etf* acabou subindo muito mais do que o *ibov*. Possivelmente por causa disso é que se não colocarmos termos determinístas o teste de raiz unitária nos diz que temos não estacionariedade. Respondemos a questão **2. c) Teste se existe ajuste unitário no vetor de cointegração.**

####Relação de causalidade de Granger
```{r}
grangertest(ibov,etf,order = 2)
grangertest(etf,ibov,order = 2)
```
Respondendo a questão **2. e) Verifique as relações de causalidade de Granger nesse sistema**: parece que ambas variáveis Granger causam uma a outra, pesar de que *eft* tem um impacto menor em *ibov* quando comparado com a relação inversa. Seria de se esperar que *ibov* Granger-causa *etf* apenas. 


####Previsão

A previsão estática considera que estamos usando o último dado que foi observado, na previsão dinâmica vamos usar os dados previstos no passo anterior.
Considere o modelo VEC com 1 lag
$$ \Delta Y_t = c + \alpha \beta' Y_{t-1} + \Gamma_1 \Delta Y_{t-1} + u_t  $$
Agora vamos construir as previsões na amostra com 30 passos, primeiro a previsão dinâmica com e sem considerar ibovespa como exógena fraca.

```{r}
#dynamic forecasting
vec$rlm[[1]][1,] #estimated alpha coefficients 
vec$rlm[[1]][2,] #constantes
t(vec$rlm[[1]][c(3,4),]) #matrix of coefficients of delta lag
t(vec$beta) #transpose of cointegration vector
#cbind(etf,ibov)
```

Vamos criar um vetor de diferenças porque usando apenas <tt> diff</tt> o R vai criar um vetor onde na primeira posição na verdade temos $\Delta Y_{2}$ não queremos isso, queremos que na posição 2 o valor seja $\Delta Y_{2}$.
```{r}
n1 <- 30 #numero de previsoes, numero de observacoes da amostra observada a ser incluida na matriz de previsão 
n2 <- length(etf)
etf.d <- c(0,diff(etf)) 
ibov.d <- c(0,diff(ibov))
```

O resultado fica: os `r n1` primeiros são valores da base original, e os outros `r n1` são valores que vamos preencher, todos eles compõem as últimas `r 2*n1` posições da amostra original.
```{r}
prv <- rbind(cbind(etf.d,ibov.d)[(n2-2*n1+1):(n2-n1),], cbind(rep(0,n1),rep(0,n1)))
prv
```

Montando o loop para a previsão dinâmica, onde usamos o valor previsto para a próxima previsão
```{r}
int1 <- 1:length(etf)
o_data <- cbind(etf,ibov,int1)#original data
o_data2 <- cbind(etf,ibov,int1) #original data holder to compare later
t <- 1
for (t in 1:n1) { 
    prv[n1+t,] <- t(
    vec$rlm[[1]][2,] + #constantes
    vec$rlm[[1]][1,] %*% #alphas
      t(vec$beta) %*% #cointegration vector
      o_data[n2-n1-1+t,]  + #Y_{t-1}
      t(vec$rlm[[1]][c(3,4),])%*% #\Gamma
      prv[n1+t-1,]  )#\Delta Y_{t-1}

o_data[n2-n1+t,c(1,2)] <- prv[n1+t,] + o_data[n2-n1-1+t,c(1,2)] #to make dynamic refresh of data
}


``` 

Podemos ver que os dados foram preenchidos
```{r}
prv
plot(o_data[(n2-100):n2,1],type='l')
plot(o_data[(n2-100):n2,2],type='l')
```


Vamos comparar os dados previstos com os dados verdadeiros:
```{r}
(o_data - o_data2)[(n2-40):n2,]

```

Vamos calcular o erro quadrático médio de previsão dinâmica usando os valores estimados dos coeficientes de ajuste, sem considerar exogeneidade fraca.

Para <tt>etf</tt> temos 
```{r}
eqm_dyn_beta_estimado_etf <- mean(((o_data - o_data2)[(n2-n1+1):n2,][,1])^2)
eqm_dyn_beta_estimado_etf
```

Para <tt>ibov</tt> temos
```{r}
eqm_dyn_beta_estimado_ibov <- mean(((o_data - o_data2)[(n2-n1+1):n2,][,2])^2)
eqm_dyn_beta_estimado_ibov
```

Vamos agora calcular a previsão dinâmica mas agora considerando que <tt>ibov</tt> é fracamente exógeno.

```{r}
o_data <- cbind(etf,ibov,int1)#original data
o_data2 <- cbind(etf,ibov,int1) #original data holder to compare later
t <- 1
for (t in 1:n1) { 
    prv[n1+t,] <- t(
    vec$rlm[[1]][2,] + #constantes
    c(vec$rlm[[1]][1,1],0) %*% #alphas  <- vamos alterar o alfa para ibov
      t(vec$beta) %*% #cointegration vector   
      o_data[n2-n1-1+t,]  + #Y_{t-1}
      t(vec$rlm[[1]][c(3,4),])%*% #\Gamma
      prv[n1+t-1,]  )#\Delta Y_{t-1}

o_data[n2-n1+t,c(1,2)] <- prv[n1+t,] + o_data[n2-n1-1+t,c(1,2)] #to make dynamic refresh of data
}
```


```{r}
plot(o_data[(n2-100):n2,1],type='l')
plot(o_data[(n2-100):n2,2],type='l')
```


Vamos calcular o erro quadrático médio de previsão dinâmica usando os valores estimados dos coeficientes de ajuste quando consideramos que <tt>ibov </tt> é fracamente exógeno.

Para <tt>etf</tt> temos 
```{r}
eqm_dyn_beta_estimado_etf <- mean(((o_data - o_data2)[(n2-n1):n2,][,1])^2)
eqm_dyn_beta_estimado_etf
```

Para <tt>ibov</tt> temos
```{r}
eqm_dyn_beta_estimado_ibov <- mean(((o_data - o_data2)[(n2-n1):n2,][,2])^2)
eqm_dyn_beta_estimado_ibov
```

###Previsão estática

Vamos fazer agora a previsão estática, onde consideramos sempre um passo a frente o dados observado. E considerando que <tt>ibov</tt> não é fracamente exógeno.

```{r}
o_data <- cbind(etf,ibov,int1)#original data
o_data2 <- cbind(etf,ibov,int1) #original data holder to compare later
t <- 1
for (t in 1:n1) { 
    prv[n1+t,] <- t(
    vec$rlm[[1]][2,] + #constantes
    vec$rlm[[1]][1,] %*% #alphas
      t(vec$beta) %*% #cointegration vector   
      o_data2[n2-n1-1+t,]  + #Y_{t-1} #estamos usando um vetor que não é atualizado, mas sim os valores verdadeiros
      t(vec$rlm[[1]][c(3,4),])%*% #\Gamma
      prv[n1+t-1,]  )#\Delta Y_{t-1}

o_data[n2-n1+t,c(1,2)] <- prv[n1+t,] + o_data2[n2-n1-1+t,c(1,2)] #to make dynamic refresh of data
}
```


```{r}
plot(o_data[(n2-100):n2,1],type='l')
plot(o_data[(n2-100):n2,2],type='l')
```


Vamos calcular o erro quadrático médio de previsão dinâmica usando os valores estimados dos coeficientes de ajuste sem considerarmos que <tt>ibov </tt> é fracamente exógeno.

Para <tt>etf</tt> temos 
```{r}
eqm_dyn_beta_estimado_etf <- mean(((o_data - o_data2)[(n2-n1):n2,][,1])^2)
eqm_dyn_beta_estimado_etf
```

Para <tt>ibov</tt> temos
```{r}
eqm_dyn_beta_estimado_ibov <- mean(((o_data - o_data2)[(n2-n1):n2,][,2])^2)
eqm_dyn_beta_estimado_ibov
```


###Previsão estática, considerando fracamente exógeno
###### Vamos fazer agora a previsão estática, onde consideramos sempre um passo a frente o dados observado

```{r}
o_data <- cbind(etf,ibov,int1)#original data
o_data2 <- cbind(etf,ibov,int1) #original data holder to compare later
t <- 1
for (t in 1:n1) { 
    prv[n1+t,] <- t(
    vec$rlm[[1]][2,] + #constantes
    c(vec$rlm[[1]][1,1],0) %*% #alphas
      t(vec$beta) %*% #cointegration vector   
      o_data2[n2-n1-1+t,]  + #Y_{t-1} #estamos usando um vetor que não é atualizado, mas sim os valores verdadeiros
      t(vec$rlm[[1]][c(3,4),])%*% #\Gamma
      prv[n1+t-1,]  )#\Delta Y_{t-1}

o_data[n2-n1+t,c(1,2)] <- prv[n1+t,] + o_data2[n2-n1-1+t,c(1,2)] #to make dynamic refresh of data
}
```


```{r}
plot(o_data[(n2-100):n2,1],type='l')
plot(o_data[(n2-100):n2,2],type='l')
```


Vamos calcular o erro quadrático médio de previsão dinâmica usando os valores estimados dos coeficientes de ajuste considerando que <tt>ibov </tt> é fracamente exógeno.

Para <tt>etf</tt> temos 
```{r}
eqm_dyn_beta_estimado_etf <- mean(((o_data - o_data2)[(n2-n1):n2,][,1])^2)
eqm_dyn_beta_estimado_etf
```

Para <tt>ibov</tt> temos
```{r}
eqm_dyn_beta_estimado_ibov <- mean(((o_data - o_data2)[(n2-n1):n2,][,2])^2)
eqm_dyn_beta_estimado_ibov
```

Respondemos a questão **2. f) Obtenha as previsões estáticas e dinâmicas para as 30 últimas observações da amostra, considerando que ibovespa é exógena fraca e não considerando esta hipótese. Compare os resultados usando erro quadrático médio de previsão.**
Vimos que o erro quadrático médio de previsão estática é melhor que seus correspondentes na previsão dinâmica, mas considerando que <tt>ibov</tt> é fracamente exógeno torna a previsão mais imprecisa. 


**2. g) Discuta a importância de exogeneidade fraca e causalidade de Granger no processo de previsão fora da amostra. **





###Questão 4
** Para a taxa de crescimento da produção industrial  **
Vamos criar a variável taxa de crescimento
```{r}
gind <- diff(indtr)
head(gind)
```
**4. a) Obtenha uma estimação da densidade espectral desta série e interprete seus resultados**
```{r}
spectrum(gind) 
```

Parece que a série de crescimento industrial é composta por um quantidade variada de frequências, sem estar apontandando para alguma frequência ou faixas de frequências que melhor representa a série.


**4. b) Realize a estimação de não-paramétrica da variância de longo prazo desta série, usando um estimador de Newey-West e um estimador Fixed-b. Discuta a diferença entre esses estimadores.**

```{r}
var(gind)
m1 <- lm(gind~1)
b <- length(gind)
(length(gind)-1) * kernHAC( m1, kernel = "Quadratic Spectral", bw = bwNeweyWest) #estimadores Newey-West
(length(gind)-1) * kernHAC( m1, kernel = "Quadratic Spectral", bw = b)  #fixe-b
(length(gind)-1) * kernHAC( m1, kernel = "Bartlett", bw = bwNeweyWest)#estimadores Newey-West
(length(gind)-1) * kernHAC( m1, kernel = "Bartlett", bw = b) #fixe-b
(length(gind)-1) * kernHAC( m1, kernel = "Parzen", bw = bwNeweyWest)#estimadores Newey-West
(length(gind)-1) * kernHAC( m1, kernel = "Parzen", bw = b) #fixe-b

```

Vemos que os estimadores fixed-b são menores do que os de Newey-West. E a variância de longo prazo encontrada pelos métodos de Newey-West são próximos da variância amostral. 


**4. c) Compare o resultado do item anterior com a variância de longo prazo usando um estimador paramétrico**
```{r}
l1 <- spec.ar(gind) 
l2<- ar(gind, order.max=10)
l2 #order selected = 1
mean(resid(l2)[!is.na(resid(l2))]^2)/(1-l2$ar^2) #variancia estimada pelo AR(1)
```
O resultado paramétrico é proximo dos estimadores Newey-West.


























